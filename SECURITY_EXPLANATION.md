Blockchain Security & Integrity ExplanationThis document explains how the principles of blockchain security and integrity are implemented in this project, as required by Section 11 of the project specification.1. Cryptographic Hashing (Data Integrity)The core of the blockchain's security is the use of a one-way cryptographic hash function, SHA256.Implementation: The BlockchainService uses a generateHash() method. This method takes all the critical data of a block (its index, timestamp, list of transactions, previous hash, and nonce) and concatenates them into a single string. This string is then passed through the hash('sha256', $data) function.Security Principle: This creates a unique "fingerprint" for the block. Even a single-byte change to any part of the block's data (e.g., changing a transaction amount from 10 to 11) will result in a completely different SHA256 hash. This makes tampering instantly detectable.2. The Unbroken Chain (Immutability)A block's hash isn't just stored by itself; it's also used to link the next block, creating a chain.Implementation: Every block stores two hashes:current_hash: Its own calculated hash.previous_hash: A copy of the current_hash from the block that came before it.Security Principle: This creates a dependency. If an attacker modifies the data in Block #5, its current_hash will change. This new, invalid hash will no longer match the previous_hash stored in Block #6. This breaks the link and invalidates the entire chain from Block #5 forward.Tampering Detection: The validateChain() function explicitly checks this link. It loops through every block and confirms that block[n].previous_hash is equal to block[n-1].current_hash. The moment a mismatch is found, the function returns false, and the UI displays "Blockchain is Broken!".3. Proof of Work (PoW) (Defense against spam/easy modification)While hashing and chaining prevent undetected tampering, Proof of Work makes tampering difficult and computationally expensive.Implementation: We use a simplified PoW rule (Section 3.4) that a block's hash must start with two zeros ("00"). The mineBlock() function finds this hash by:Gathering all block data.Trying a nonce (a random number, starting at 0).Calculating the hash.Checking if the hash starts with "00".If not, it increments the nonce (e.g., 1, 2, 3...) and repeats the process, calculating thousands of hashes until a valid one is found.Security Principle: This "mining" process takes time and CPU power. If an attacker modifies Block #5, they don't just break the chainâ€”they would also have to re-mine Block #5 to find a new valid hash (starting with "00"). Then, they would have to re-mine Block #6, Block #7, and every single block after it to re-establish the chain, all while new, valid blocks are being added by others. This "race against the chain" makes tampering practically impossible.4. Application-Level Security (Section 8)In addition to blockchain principles, standard application security rules are enforced:Input Validation: The API validates all inputs (e.g., amount > 0, sender != receiver) to prevent corrupt data from ever entering the "pending" pool.Immutability: The application logic provides no API endpoints or UI features to edit or delete existing blocks or transactions, enforcing the immutability principle at the application layer.